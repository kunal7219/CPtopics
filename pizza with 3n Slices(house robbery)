class Solution {
    int solve(int index,int endindex,vector<int>& path,int n){
        if(n==0 || index>endindex){
            return 0;
        }
        int take = path[index]+ solve(index+2,endindex,path,n-1);
        int nottake = 0+ solve(index+1,endindex,path,n);
        return max(take,nottake);
    }
    int solveMem(int index,int endindex,vector<int>& path,int n,vector<vector<int>>& dp){
        if(n==0 || index>endindex){
            return 0;
        }
        if(dp[index][n]!=-1){
            return dp[index][n];
        }
        int take = path[index]+ solveMem(index+2,endindex,path,n-1,dp);
        int nottake = 0+ solveMem(index+1,endindex,path,n,dp);
        return dp[index][n]=max(take,nottake);
    }
    int solveTab(vector<int>& slices){
        int n = slices.size();
        vector<vector<int>> dp(n+2,vector<int>(n+2,0));
  
        for(int index=n-1;index>=1;index--){
            for(int k=1;k<=(n/3);k++){
                int take = slices[index]+ dp[index+2][k-1];
                int nottake = dp[index+1][k];
                dp[index][k]=max(take,nottake);
            }
        }
        vector<vector<int>> dp1(n+2,vector<int>(n+2,0));

        for(int index=n-2;index>=0;index--){
            for(int k=1;k<=(n/3);k++){
                int take = slices[index]+ dp1[index+2][k-1];
                int nottake = dp1[index+1][k];
                dp1[index][k]=max(take,nottake);
            }
        }
        return max(dp1[0][n/3],dp[1][n/3]);
    }

    int solveSpaceOP(vector<int>& slices){
        int n = slices.size();
        vector<int> curr1(n+1,0);
        vector<int> prev1(n+1,0);
        vector<int> next1(n+1,0);

  
        for(int index=n-1;index>=1;index--){
            for(int k=1;k<=(n/3);k++){
                int take = slices[index]+ next1[k-1];
                int nottake = curr1[k];
                prev1[k]=max(take,nottake);
            }
            next1=curr1;
            curr1=prev1;
        }
        vector<int> curr(n+1,0);
        vector<int> prev(n+1,0);
        vector<int> next(n+1,0);

  
        for(int index=n-2;index>=0;index--){
            for(int k=1;k<=(n/3);k++){
                int take = slices[index]+ next[k-1];
                int nottake = curr[k];
                prev[k]=max(take,nottake);
            }
            next=curr;
            curr=prev;
        }
        return max(curr1[n/3],curr[n/3]);
    }
public:
    int maxSizeSlices(vector<int>& slices) {
        
        int n = slices.size();
        //int case1 = solve(0,n-2,slices,n/3);
        //int case2 = solve(1,n-1,slices,n/3);
        //return max(case2,case1);  

        //vector<vector<int>> dp1(n+1,vector<int>(n+1,-1));
        //int case1 = solveMem(0,n-2,slices,n/3,dp1);
        //vector<vector<int>> dp2(n+1,vector<int>(n+1,-1));
        //int case2 = solveMem(1,n-1,slices,n/3,dp2);
        //return max(case2,case1);

        return solveSpaceOP(slices);

    }
};
