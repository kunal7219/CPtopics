class Solution {
    private:
    int solveMem(int i,int n,int hold,int count,vector<int>& prices,vector<vector<vector<int>>>& dp){
        if(count<=0){
            return 0;
        }
        if(i>=n){
            return 0;
        }
        if(dp[i][hold][count]!=-1){
            return dp[i][hold][count];
        }
        // hold what you have
        int op1 = solveMem(i+1,n,hold,count,prices,dp);
        int op2 = INT_MIN,op3=INT_MIN;
        if(hold==0){
            // buying
            op2 = -prices[i] + solveMem(i+1,n,1,count,prices,dp); 
        }
        else{
            // selling
            op3 = prices[i] + solveMem(i+1,n,0,count-1,prices,dp);
        }
        return dp[i][hold][count]=max({op1,op2,op3});
    }
     int solveTab(vector<int>& prices,int k){
        int n=prices.size();
        vector<vector<vector<int> > > dp(n+1, vector<vector<int> >(2, vector<int>(k+1,0)));
        for(int i=n-1;i>=0;i--){
            for(int hold=0;hold<=1;hold++){
                for(int count=1;count<=k;count++){
                int op1 = dp[i+1][hold][count];
                int op2 = INT_MIN,op3=INT_MIN;
                if(hold==0){
                // buying
                op2 = -prices[i] + dp[i+1][1][count]; 
                }
                else{
                // selling
                op3 = prices[i] + dp[i+1][0][count-1];
                }
                dp[i][hold][count]=max({op1,op2,op3});
            }
        }
        }
        return dp[0][0][k];
    }
    int solveSpaceOP(vector<int>& prices,int k){
        int n=prices.size();
        vector<vector<int>> curr(2,vector<int>(k+1,0));
        vector<vector<int>> next(2,vector<int>(k+1,0));

        for(int i=n-1;i>=0;i--){
            for(int hold=0;hold<=1;hold++){
                for(int count=1;count<=k;count++){
                int op1 = next[hold][count];
                int op2 = INT_MIN,op3=INT_MIN;
                if(hold==0){
                // buying
                op2 = -prices[i] + next[1][count]; 
                }
                else{
                // selling
                op3 = prices[i] + next[0][count-1];
                }
                curr[hold][count]=max({op1,op2,op3});
            }
        }
        next=curr;
        }
        return curr[0][k];
    }
public:
    int maxProfit(int k, vector<int>& prices) {
        int n=prices.size();
        //int hold = 0;
        //int count=k;
        //vector<vector<vector<int> > > dp(n+1, vector<vector<int> >(2, vector<int>(k+1,-1)));
        //return solveMem(0,n,hold,count,prices,dp);

        //return solveTab(prices,k);

        return solveSpaceOP(prices,k);
    }
};
